#include <iostream>
using namespace std;
 class Base 
{
public: 
	Base()
	{ cout << "Base::Base()\n"; }   
	Base(const Base&) 
	{ cout << "Base::copy()\n"; }  
	virtual void f()
	{ cout << "Base::f()\n"; }    
	virtual ~Base() 
	{ cout << "Base::~\n"; } 
 }; 

class Der : public Base 
{ public:    
	Der()
	{ cout << "Der::Der()\n"; }  
	Der(const Der&) 
	{ cout << "Der::Copy()\n"; }   
	void f()
	{ cout << "Der::f()\n"; }   
	~Der() 
	{ cout << "Der::~\n"; } 
}; 

void g1(Base a)
{
	cout << "F:";  
	a.f();
}
void g2(Der a) 
{
	cout << "F:";  
	a.f(); 
} 
void g3(Base& a)
{
	cout << "F:"; 
	a.f(); 
}

void main() 
{
	cout << "1:\n"; 
	Der d; 
	//Base::Base()
	//Der::Der()
	//

	cout << "2:\n"; 
	g1(d); //получава копие на обекта, накрая трябва деструктора да се извика

	//Base::Copy()
	//F: 
	//Base::f()
	//Base::~\n


	cout << "3:\n";   
	g2(d); 
	// само тук имаме полиморфизъм
	//Base::Base() 
	//copy конструктора извиква базовия конструктор на Base класа 
	//ако не сме написали копиращ инструктор, то системния ще извиква копи конструктора на базовия клас
	//Der::Copy()

	//F: 
	//Der::f()
	//Der::~\n"
	//Base::~\n" 


	cout << "4:\n";//понеже не копираме обект, няма какво да деструктнем от scope-a
	g3(d); 
	//F: 
	//Der::f()

	cout << "5:\n";  //деструктирането става след излизане на мейн така че няма да излезне в cout-не
    //Der::~
	//Base::~

	system("pause");

}

//ако имаме член данни от тип някакъв клас - техните конструктори се извизкат чак след като се е извикал констр
//на класа който ги съдържа -
//конструктора на виртуалните базови  класове
//конструктора на общи базовите класове
//конструктора на членовете
//тялото на конструктора




//при десструктор - 
//в обратен ред - 
//тялото на деструктора
//деструктора на членовете
//деструкторите на базовите класове
//деструкторите на виртуалните базови  класове

